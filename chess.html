<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×©×—-×’×œ ğŸ‘‘ ×¨××ª ×’××•×Ÿ</title>
    <style>
        :root {
            --bg-dark: #020617;
            --panel-bg: #1e293b;
            --gold: #fbbf24;
            --gold-glow: rgba(251, 191, 36, 0.5);
            --blue: #3b82f6;
            --white-piece: #e2e8f0;
            --black-piece: #0f172a;
            --square-light: #94a3b8;
            --square-dark: #334155;
            --highlight: rgba(251, 191, 36, 0.7);
            --last-move: rgba(59, 130, 246, 0.5);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at top, #1e293b 0%, #020617 100%);
            color: white;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            direction: rtl;
        }

        header {
            text-align: center;
            margin: 20px 0;
            animation: fadeIn 1s ease-in;
        }

        h1 {
            color: var(--gold);
            font-size: 3.5rem;
            margin: 0;
            text-shadow: 0 0 25px var(--gold-glow);
            font-weight: 800;
        }

        .subtitle {
            color: #cbd5e1;
            letter-spacing: 1.5px;
            font-size: 1.2rem;
            margin-top: 5px;
        }

        .game-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 20px;
        }

        /* ×œ×•×— ×”×©×—××˜ */
        .board {
            display: grid;
            grid-template-columns: repeat(8, 75px);
            grid-template-rows: repeat(8, 75px);
            border: 12px solid #1e293b;
            border-radius: 6px;
            box-shadow: 0 25px 60px rgba(0,0,0,0.6);
            user-select: none;
            position: relative;
        }

        .square {
            width: 75px;
            height: 75px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 50px;
            cursor: pointer;
            position: relative;
        }

        .sq-light { background-color: var(--square-light); }
        .sq-dark { background-color: var(--square-dark); }

        .piece {
            z-index: 2;
            cursor: grab;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .piece.white { color: var(--white-piece); text-shadow: 0 4px 6px rgba(0,0,0,0.6); }
        .piece.black { color: var(--black-piece); text-shadow: 0 0 0 transparent; }

        /* ××¤×§×˜×™× */
        .selected { background-color: var(--highlight) !important; box-shadow: inset 0 0 15px var(--gold); }
        .last-move { background-color: var(--last-move) !important; }
        
        .valid-move::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: rgba(0, 255, 100, 0.6);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(0, 255, 100, 0.8);
        }

        .valid-capture {
            box-shadow: inset 0 0 0 4px rgba(220, 38, 38, 0.6);
        }

        /* ×¤×× ×œ ×¦×“ */
        .sidebar {
            background: var(--panel-bg);
            padding: 25px;
            border-radius: 16px;
            border: 1px solid rgba(251, 191, 36, 0.3);
            width: 300px;
            text-align: center;
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .status-box {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .status {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--gold);
            min-height: 1.5em;
        }

        .turn-indicator {
            display: inline-block;
            padding: 6px 16px;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.4);
            border-radius: 20px;
            font-size: 1rem;
            margin-bottom: 10px;
            color: #93c5fd;
        }

        button {
            background: linear-gradient(135deg, #eab308, #b45309);
            border: none;
            padding: 14px 24px;
            color: white;
            font-weight: 800;
            font-size: 1.2rem;
            border-radius: 10px;
            cursor: pointer;
            width: 100%;
            box-shadow: 0 4px 15px rgba(234, 179, 8, 0.4);
            transition: all 0.2s;
        }

        button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(234, 179, 8, 0.6); }
        button:active { transform: translateY(0); }

        .loader {
            display: none;
            margin: 10px auto;
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--gold);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }

        @media (max-width: 800px) {
            .board { grid-template-columns: repeat(8, 11vw); grid-template-rows: repeat(8, 11vw); border-width: 5px; }
            .square { width: 11vw; height: 11vw; font-size: 8vw; }
            h1 { font-size: 2.5rem; }
        }
    </style>
</head>
<body>

    <header>
        <h1>×©×—-×’×œ ğŸ‘‘</h1>
        <div class="subtitle">×¨××ª ×’××•×Ÿ - × ×¨××” ××•×ª×š ×× ×¦×—</div>
    </header>

    <div class="game-container">
        <div class="board" id="board"></div>

        <div class="sidebar">
            <div class="status-box">
                <div class="turn-indicator" id="turn-text">×ª×•×¨: ×’×œ (×œ×‘×Ÿ)</div>
                <div class="status" id="status-msg">×‘×”×¦×œ×—×”!</div>
                <div class="loader" id="ai-loader"></div>
            </div>
            
            <div style="text-align: right; font-size: 0.9rem; color: #94a3b8; line-height: 1.6;">
                <div>â™” <b>×’×œ:</b> ××©×—×§ ×‘×œ×‘×Ÿ</div>
                <div>â™š <b>××—×©×‘ (AI):</b> ×× ×ª×— 3 ×¦×¢×“×™× ×§×“×™××”</div>
                <div style="margin-top: 10px; font-size: 0.8rem; color: #64748b;">* ×”×‘×•×˜ ××©×ª××© ×‘××œ×’×•×¨×™×ª× Minimax</div>
            </div>

            <button onclick="initGame()">ğŸ³ï¸ ××©×—×§ ×—×“×©</button>
        </div>
    </div>

    <script>
        // --- ×”×’×“×¨×•×ª ---
        const boardEl = document.getElementById('board');
        const statusEl = document.getElementById('status-msg');
        const turnEl = document.getElementById('turn-text');
        const loader = document.getElementById('ai-loader');

        const PIECES = {
            w: { k: 'â™”', q: 'â™•', r: 'â™–', b: 'â™—', n: 'â™˜', p: 'â™™' },
            b: { k: 'â™š', q: 'â™›', r: 'â™œ', b: 'â™', n: 'â™', p: 'â™Ÿï¸' }
        };

        // × ×™×§×•×“ ×‘×¡×™×¡×™ ×œ×›×œ×™×
        const PIECE_VALUES = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };

        // ×˜×‘×œ××•×ª ××™×§×•× (PST) - ×”×‘×•×˜ ×™×•×“×¢ ××™×¤×” ×›×œ×™× ×¦×¨×™×›×™× ×œ×¢××•×“
        // ×¢×‘×•×¨ ×œ×‘×Ÿ (×”×•×¤×›×™× ×¢×‘×•×¨ ×©×—×•×¨)
        const PST = {
            p: [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [50, 50, 50, 50, 50, 50, 50, 50],
                [10, 10, 20, 30, 30, 20, 10, 10],
                [5,  5, 10, 25, 25, 10,  5,  5],
                [0,  0,  0, 20, 20,  0,  0,  0],
                [5, -5,-10,  0,  0,-10, -5,  5],
                [5, 10, 10,-20,-20, 10, 10,  5],
                [0,  0,  0,  0,  0,  0,  0,  0]
            ],
            n: [
                [-50,-40,-30,-30,-30,-30,-40,-50],
                [-40,-20,  0,  0,  0,  0,-20,-40],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  5, 15, 20, 20, 15,  5,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  5, 10, 15, 15, 10,  5,-30],
                [-40,-20,  0,  5,  5,  0,-20,-40],
                [-50,-40,-30,-30,-30,-30,-40,-50]
            ],
            // ×©××¨ ×”×›×œ×™× ××§×‘×œ×™× ×œ×•×—×•×ª ×¤×©×•×˜×™× ×™×•×ª×¨ ×œ×¦×•×¨×š ×§×•×“ ×§×¦×¨
            b: [
                [-20,-10,-10,-10,-10,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5, 10, 10,  5,  0,-10],
                [-10,  5,  5, 10, 10,  5,  5,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10, 10, 10, 10, 10, 10, 10,-10],
                [-10,  5,  0,  0,  0,  0,  5,-10],
                [-20,-10,-10,-10,-10,-10,-10,-20]
            ]
        };

        const START_FEN = [
            ['br','bn','bb','bq','bk','bb','bn','br'],
            ['bp','bp','bp','bp','bp','bp','bp','bp'],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['wp','wp','wp','wp','wp','wp','wp','wp'],
            ['wr','wn','wb','wq','wk','wb','wn','wr']
        ];

        let board = [];
        let turn = 'w';
        let selectedSquare = null;
        let validMoves = [];
        let gameOver = false;
        let lastMove = null;

        // --- ××ª×—×•×œ ---

        function initGame() {
            board = JSON.parse(JSON.stringify(START_FEN));
            turn = 'w';
            gameOver = false;
            selectedSquare = null;
            validMoves = [];
            lastMove = null;
            
            updateStatus("×”××©×—×§ ×”×ª×—×™×œ!", false);
            drawBoard();
        }

        function drawBoard() {
            boardEl.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const sq = document.createElement('div');
                    sq.className = `square ${(r + c) % 2 === 0 ? 'sq-light' : 'sq-dark'}`;
                    sq.dataset.r = r;
                    sq.dataset.c = c;
                    
                    if (selectedSquare && selectedSquare.r === r && selectedSquare.c === c) sq.classList.add('selected');

                    if (lastMove) {
                        if ((lastMove.from.r === r && lastMove.from.c === c) || 
                            (lastMove.to.r === r && lastMove.to.c === c)) {
                            sq.classList.add('last-move');
                        }
                    }

                    const isValidMove = validMoves.find(m => m.r === r && m.c === c);
                    if (isValidMove) {
                        sq.classList.add('valid-move');
                        if (board[r][c] !== '') sq.classList.add('valid-capture');
                    }

                    const pieceCode = board[r][c];
                    if (pieceCode) {
                        const color = pieceCode[0];
                        const type = pieceCode[1];
                        const span = document.createElement('span');
                        span.className = `piece ${color === 'w' ? 'white' : 'black'}`;
                        span.textContent = PIECES[color][type];
                        sq.appendChild(span);
                    }

                    sq.onclick = () => onSquareClick(r, c);
                    boardEl.appendChild(sq);
                }
            }
        }

        function updateStatus(msg, thinking) {
            statusEl.textContent = msg;
            loader.style.display = thinking ? 'block' : 'none';
        }

        // --- ×œ×•×’×™×§×” ---

        function onSquareClick(r, c) {
            if (gameOver || turn === 'b') return; 

            const move = validMoves.find(m => m.r === r && m.c === c);
            if (move) {
                executeMove(selectedSquare, move);
                return;
            }

            const piece = board[r][c];
            if (piece && piece.startsWith('w')) {
                selectedSquare = {r, c};
                validMoves = getSafeMoves(r, c);
                drawBoard();
            } else {
                selectedSquare = null;
                validMoves = [];
                drawBoard();
            }
        }

        function executeMove(from, to) {
            const piece = board[from.r][from.c];
            board[to.r][to.c] = piece;
            board[from.r][from.c] = '';

            // ×”×›×ª×¨×” ×œ××œ×›×”
            if (piece[1] === 'p' && (to.r === 0 || to.r === 7)) {
                board[to.r][to.c] = piece[0] + 'q';
            }

            lastMove = { from, to };
            
            if (isCheckmate(turn === 'w' ? 'b' : 'w')) {
                gameOver = true;
                drawBoard();
                const winner = turn === 'w' ? "× ×™×¦×—×ª! (×’××•×Ÿ)" : "×”××—×©×‘ × ×™×¦×—";
                updateStatus("××˜! " + winner, false);
                return;
            }

            turn = turn === 'w' ? 'b' : 'w';
            selectedSquare = null;
            validMoves = [];
            
            const turnName = turn === 'w' ? "×’×œ (×œ×‘×Ÿ)" : "××—×©×‘ (×©×—×•×¨)";
            turnEl.textContent = "×ª×•×¨: " + turnName;
            
            if (isInCheck(turn)) {
                updateStatus("×©×—! ×”××œ×š ×‘×¡×›× ×”!", false);
            } else {
                updateStatus(turn === 'w' ? "×ª×•×¨×š ×’×œ" : "××—×©×‘ ××ª ×”××”×œ×š...", turn === 'b');
            }

            drawBoard();

            if (turn === 'b' && !gameOver) {
                // ×”×©×”×™×” ×§×˜× ×” ×œ×¦×™×•×¨ ×”×œ×•×— ×œ×¤× ×™ ×©×”-JS ×—×•×¡× ××•×ª×• ×œ×—×™×©×•×‘
                setTimeout(makeBestMove, 100);
            }
        }

        // --- ×‘×™× ×” ××œ××›×•×ª×™×ª (Minimax) ---

        function makeBestMove() {
            // ×¢×•××§ ×—×™×¤×•×© 3 = ×”××—×©×‘ ×¨×•××” 3 ××”×œ×›×™× ×§×“×™××” (×©×œ×š ×•×©×œ×•)
            const depth = 3; 
            const bestMove = minimaxRoot(depth, board, true);
            
            if (bestMove) {
                // ×”××¨×” ××¤×•×¨××˜ ×”×× ×•×¢ ×œ×¤×•×¨××˜ ×”××©×—×§ ×©×œ× ×•
                const from = {r: bestMove.fromR, c: bestMove.fromC};
                const to = {r: bestMove.toR, c: bestMove.toC};
                executeMove(from, to);
            } else {
                gameOver = true;
                updateStatus("×ª×™×§×• (×¤×˜)!", false);
            }
        }

        // ×¤×•× ×§×¦×™×™×ª ×”×¢×¨×™×›×” (×”××•×— ×©×œ ×”××—×©×‘)
        function evaluateBoard(bd) {
            let totalEvaluation = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = bd[r][c];
                    if (piece) {
                        const type = piece[1];
                        const color = piece[0];
                        
                        // × ×™×§×•×“ ×—×•××¨×™
                        let value = PIECE_VALUES[type] || 0;
                        
                        // × ×™×§×•×“ ××™×§×•× (PST)
                        if (type === 'p' || type === 'n' || type === 'b') {
                            const table = PST[type] || PST['b']; // ×‘×¨×™×¨×ª ××—×“×œ
                            // ×× ×–×” ×œ×‘×Ÿ ××©×ª××©×™× ×‘×˜×‘×œ×” ×¨×’×™×œ, ×× ×©×—×•×¨ ×”×•×¤×›×™× ××ª ×”×œ×•×— (××¨××”)
                            if (color === 'w') {
                                value += table[r][c];
                            } else {
                                value += table[7-r][c]; 
                            }
                        }

                        totalEvaluation = totalEvaluation + (color === 'b' ? value : -value);
                    }
                }
            }
            return totalEvaluation;
        }

        function minimaxRoot(depth, bd, isMaximizingPlayer) {
            const newGameMoves = generateAllMoves(bd, 'b');
            let bestMove = -99999;
            let bestMoveFound = null;

            for (let i = 0; i < newGameMoves.length; i++) {
                const move = newGameMoves[i];
                // ×‘×¦×¢ ××”×œ×š ×–×× ×™
                const savedPiece = bd[move.toR][move.toC];
                bd[move.toR][move.toC] = bd[move.fromR][move.fromC];
                bd[move.fromR][move.fromC] = '';

                const value = minimax(depth - 1, bd, -100000, 100000, !isMaximizingPlayer);
                
                // ×‘×˜×œ ××”×œ×š
                bd[move.fromR][move.fromC] = bd[move.toR][move.toC];
                bd[move.toR][move.toC] = savedPiece;

                if (value >= bestMove) {
                    bestMove = value;
                    bestMoveFound = move;
                }
            }
            return bestMoveFound;
        }

        function minimax(depth, bd, alpha, beta, isMaximizingPlayer) {
            if (depth === 0) {
                return evaluateBoard(bd);
            }

            const color = isMaximizingPlayer ? 'b' : 'w';
            const newGameMoves = generateAllMoves(bd, color);

            if (newGameMoves.length === 0) {
                // ×‘×“×™×§×ª ××˜ ××• ×¤×˜ ×‘×§×¦×” ×”×¢×¥
                // (×¤×™×©×•×˜: ××—×–×™×¨ ×¢×¨×š ×’×‘×•×”/× ××•×š ×× ×”××œ×š ×‘×¡×›× ×”, ××• 0 ×‘×ª×™×§×•)
                // ×›××Ÿ × ×©×ª××© ×‘×”×¢×¨×›×” ×¡×˜×˜×™×ª ×›×“×™ ×œ×—×¡×•×š ×–××Ÿ ×—×™×©×•×‘
                return evaluateBoard(bd);
            }

            if (isMaximizingPlayer) {
                let bestMove = -99999;
                for (let i = 0; i < newGameMoves.length; i++) {
                    const move = newGameMoves[i];
                    
                    const savedPiece = bd[move.toR][move.toC];
                    // ×‘×•× ×•×¡ ×§×˜×Ÿ ×œ××›×™×œ×•×ª ×›×“×™ ×œ×™×™×¢×œ ××ª ×”××œ×’×•×¨×™×ª× (Move Ordering ×¤×¨×™××™×˜×™×‘×™)
                    if (savedPiece) { 
                        // ××•×¤×˜×™××™×–×¦×™×”: ×× ××›×œ× ×•, × ×‘×“×•×§ ×§×•×“×
                    }
                    
                    bd[move.toR][move.toC] = bd[move.fromR][move.fromC];
                    bd[move.fromR][move.fromC] = '';
                    
                    bestMove = Math.max(bestMove, minimax(depth - 1, bd, alpha, beta, !isMaximizingPlayer));
                    
                    bd[move.fromR][move.fromC] = bd[move.toR][move.toC];
                    bd[move.toR][move.toC] = savedPiece;

                    alpha = Math.max(alpha, bestMove);
                    if (beta <= alpha) {
                        return bestMove;
                    }
                }
                return bestMove;
            } else {
                let bestMove = 99999;
                for (let i = 0; i < newGameMoves.length; i++) {
                    const move = newGameMoves[i];
                    
                    const savedPiece = bd[move.toR][move.toC];
                    bd[move.toR][move.toC] = bd[move.fromR][move.fromC];
                    bd[move.fromR][move.fromC] = '';
                    
                    bestMove = Math.min(bestMove, minimax(depth - 1, bd, alpha, beta, !isMaximizingPlayer));
                    
                    bd[move.fromR][move.fromC] = bd[move.toR][move.toC];
                    bd[move.toR][move.toC] = savedPiece;

                    beta = Math.min(beta, bestMove);
                    if (beta <= alpha) {
                        return bestMove;
                    }
                }
                return bestMove;
            }
        }

        function generateAllMoves(bd, color) {
            let moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (bd[r][c] && bd[r][c].startsWith(color)) {
                        const pieceMoves = getPseudoMoves(r, c, bd);
                        moves.push(...pieceMoves.map(m => ({fromR: r, fromC: c, toR: m.r, toC: m.c})));
                    }
                }
            }
            // ×œ×¦×•×¨×š ×‘×™×¦×•×¢×™×, ×‘×ª×•×š ×”××™× ×™××§×¡ ×× ×—× ×• ××¡×ª××›×™× ×¢×œ pseudo moves
            // ××‘×œ ××¡× × ×™× ×œ×§×™×—×ª ××œ×š ×›×“×™ ×©×”×‘×•×˜ ×™×“×¢ ×©×–×” ××”×œ×š ×œ× ×—×•×§×™/××¤×¡×™×“
            // ×‘×’×¨×¡×” ×¤×©×•×˜×” ×–×•, ×× ×—× ×• × ×•×ª× ×™× ×œ×• ×œ×—×©×‘ ×”×›×œ, ××‘×œ ×× ×”×•× ×™×›×•×œ ×œ××›×•×œ ××œ×š ×–×” ×¦×™×•×Ÿ ××™× ×¡×•×¤×™
            return moves;
        }

        // --- ×œ×•×’×™×§×ª ×ª× ×•×¢×” ×§×™×™××ª (×œ× ×©×•× ×ª×”, ×¨×§ ×©×™××•×© ×—×•×–×¨) ---

        function getSafeMoves(r, c) {
            const piece = board[r][c];
            if (!piece) return [];
            const rawMoves = getPseudoMoves(r, c, board);
            const myColor = piece[0];
            return rawMoves.filter(m => {
                const tempBoard = JSON.parse(JSON.stringify(board));
                tempBoard[m.r][m.c] = tempBoard[r][c];
                tempBoard[r][c] = '';
                return !isKingInDanger(tempBoard, myColor);
            });
        }

        function getPseudoMoves(r, c, bd) {
            const piece = bd[r][c];
            const type = piece[1];
            const color = piece[0];
            const moves = [];
            const check = (tr, tc) => {
                if (tr < 0 || tr > 7 || tc < 0 || tc > 7) return 'out';
                const target = bd[tr][tc];
                if (target === '') return 'empty';
                if (target[0] !== color) return 'capture';
                return 'blocked';
            };

            if (type === 'p') {
                const dir = color === 'w' ? -1 : 1;
                const startRow = color === 'w' ? 6 : 1;
                if (check(r + dir, c) === 'empty') {
                    moves.push({r: r + dir, c: c});
                    if (r === startRow && check(r + dir * 2, c) === 'empty') moves.push({r: r + dir * 2, c: c});
                }
                if (check(r + dir, c - 1) === 'capture') moves.push({r: r + dir, c: c - 1});
                if (check(r + dir, c + 1) === 'capture') moves.push({r: r + dir, c: c + 1});
            } else if (type === 'n') {
                [[ -2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(j => {
                    const res = check(r + j[0], c + j[1]);
                    if (res === 'empty' || res === 'capture') moves.push({r: r+j[0], c: c+j[1]});
                });
            } else if (type === 'k') {
                [[ -1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(s => {
                    const res = check(r + s[0], c + s[1]);
                    if (res === 'empty' || res === 'capture') moves.push({r: r+s[0], c: c+s[1]});
                });
            } else {
                const dirs = [];
                if (type === 'r' || type === 'q') dirs.push([0,1],[0,-1],[1,0],[-1,0]);
                if (type === 'b' || type === 'q') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
                dirs.forEach(d => {
                    let tr = r + d[0];
                    let tc = c + d[1];
                    while (true) {
                        const res = check(tr, tc);
                        if (res === 'out' || res === 'blocked') break;
                        moves.push({r: tr, c: tc});
                        if (res === 'capture') break;
                        tr += d[0]; tc += d[1];
                    }
                });
            }
            return moves;
        }

        function isInCheck(color) { return isKingInDanger(board, color); }

        function isKingInDanger(bd, color) {
            let kR, kC;
            for (let r=0; r<8; r++) {
                for (let c=0; c<8; c++) {
                    if (bd[r][c] === color + 'k') { kR = r; kC = c; break; }
                }
            }
            if (kR === undefined) return true; 

            const enemy = color === 'w' ? 'b' : 'w';

            // ×¨×’×œ×™×
            if (color === 'w') {
                 if (bd[kR-1]?.[kC-1] === 'bp') return true;
                 if (bd[kR-1]?.[kC+1] === 'bp') return true;
             } else {
                 if (bd[kR+1]?.[kC-1] === 'wp') return true;
                 if (bd[kR+1]?.[kC+1] === 'wp') return true;
             }

            // ×¤×¨×©×™×
            const knights = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
            for (let k of knights) {
                if (bd[kR+k[0]]?.[kC+k[1]] === enemy + 'n') return true;
            }

            // ×§×•×•×™×
            const dirs = [
                {d:[1,1], p:['b','q']}, {d:[1,-1], p:['b','q']}, {d:[-1,1], p:['b','q']}, {d:[-1,-1], p:['b','q']},
                {d:[0,1], p:['r','q']}, {d:[0,-1], p:['r','q']}, {d:[1,0], p:['r','q']}, {d:[-1,0], p:['r','q']}
            ];
            for (let setup of dirs) {
                let r = kR + setup.d[0];
                let c = kC + setup.d[1];
                while(r>=0 && r<8 && c>=0 && c<8) {
                    const p = bd[r][c];
                    if (p) {
                        if (p[0] === enemy && setup.p.includes(p[1])) return true;
                        break;
                    }
                    r += setup.d[0]; c += setup.d[1];
                }
            }
             const kings = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
             for (let k of kings) {
                 if (bd[kR+k[0]]?.[kC+k[1]] === enemy + 'k') return true;
             }
            return false;
        }

        function isCheckmate(color) {
            for (let r=0; r<8; r++) {
                for (let c=0; c<8; c++) {
                    if (board[r][c].startsWith(color)) {
                        if (getSafeMoves(r, c).length > 0) return false;
                    }
                }
            }
            return isInCheck(color);
        }

        initGame();
    </script>
</body>
</html>
