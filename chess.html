<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×©×—-×’×œ ğŸ‘‘ ×”××©×—×§ ×©×œ ×’×œ</title>
    <style>
        :root {
            --bg-dark: #0f172a;
            --panel-bg: #1e293b;
            --gold: #fbbf24;
            --gold-glow: rgba(251, 191, 36, 0.3);
            --blue: #3b82f6;
            --white-piece: #f1f5f9;
            --black-piece: #0f172a;
            --square-light: #cbd5e1;
            --square-dark: #475569;
            --highlight: rgba(251, 191, 36, 0.6);
            --last-move: rgba(59, 130, 246, 0.4);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle, #1e293b 0%, #020617 100%);
            color: white;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            direction: rtl;
        }

        header {
            text-align: center;
            margin: 20px 0;
        }

        h1 {
            color: var(--gold);
            font-size: 3rem;
            margin: 0;
            text-shadow: 0 0 20px var(--gold-glow);
        }

        .game-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 10px;
        }

        /* ×œ×•×— ×”×©×—××˜ */
        .board {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            border: 10px solid #334155;
            border-radius: 8px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            user-select: none;
        }

        .square {
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 45px;
            cursor: pointer;
            position: relative;
        }

        .sq-light { background-color: var(--square-light); }
        .sq-dark { background-color: var(--square-dark); }

        .piece {
            z-index: 2;
            cursor: grab;
            transition: transform 0.1s;
        }
        
        .piece.white { color: var(--white-piece); text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        .piece.black { color: var(--black-piece); }

        /* ××¤×§×˜×™× */
        .selected { background-color: var(--highlight) !important; }
        .last-move { background-color: var(--last-move) !important; }
        
        .valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(0, 200, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
        }

        .valid-capture {
            box-shadow: inset 0 0 0 4px rgba(200, 0, 0, 0.5);
        }

        /* ×¤×× ×œ ×¦×“ */
        .sidebar {
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--gold);
            width: 280px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .status {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 20px;
            min-height: 40px;
            color: var(--gold);
        }

        .turn-indicator {
            display: inline-block;
            padding: 5px 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            font-size: 1rem;
            margin-bottom: 20px;
        }

        button {
            background: linear-gradient(135deg, #eab308, #ca8a04);
            border: none;
            padding: 12px 24px;
            color: #0f172a;
            font-weight: bold;
            font-size: 1.1rem;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            transition: transform 0.1s;
        }

        button:active { transform: scale(0.95); }
        button:hover { filter: brightness(1.1); }

        @media (max-width: 700px) {
            .board {
                grid-template-columns: repeat(8, 11vw);
                grid-template-rows: repeat(8, 11vw);
                border-width: 5px;
            }
            .square { width: 11vw; height: 11vw; font-size: 8vw; }
            h1 { font-size: 2rem; }
        }
    </style>
</head>
<body>

    <header>
        <h1>×©×—-×’×œ ğŸ‘‘</h1>
        <div style="color: #94a3b8; letter-spacing: 1px;">×”×××œ×›×” ×©×œ ×’×œ</div>
    </header>

    <div class="game-container">
        <div class="board" id="board"></div>

        <div class="sidebar">
            <div class="turn-indicator" id="turn-text">×ª×•×¨: ×’×œ (×œ×‘×Ÿ)</div>
            <div class="status" id="status-msg">×‘×”×¦×œ×—×” ×’×œ!</div>
            
            <div style="text-align: right; margin-top: 20px; font-size: 0.9rem; color: #cbd5e1;">
                <div>â™” ×’×œ ××©×—×§ ×‘×œ×‘×Ÿ</div>
                <div>â™š ×”××—×©×‘ ××©×—×§ ×‘×©×—×•×¨</div>
            </div>

            <button onclick="initGame()">××©×—×§ ×—×“×©</button>
        </div>
    </div>

    <script>
        // --- ×”×’×“×¨×•×ª ×‘×¡×™×¡ ---
        const boardEl = document.getElementById('board');
        const statusEl = document.getElementById('status-msg');
        const turnEl = document.getElementById('turn-text');

        const PIECES = {
            w: { k: 'â™”', q: 'â™•', r: 'â™–', b: 'â™—', n: 'â™˜', p: 'â™™' },
            b: { k: 'â™š', q: 'â™›', r: 'â™œ', b: 'â™', n: 'â™', p: 'â™Ÿï¸' }
        };

        const START_FEN = [
            ['br','bn','bb','bq','bk','bb','bn','br'],
            ['bp','bp','bp','bp','bp','bp','bp','bp'],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['wp','wp','wp','wp','wp','wp','wp','wp'],
            ['wr','wn','wb','wq','wk','wb','wn','wr']
        ];

        // ××©×ª× ×™ ××©×—×§
        let board = [];
        let turn = 'w'; // w = Gal, b = Computer
        let selectedSquare = null; // {r, c}
        let validMoves = []; // Array of {r,c}
        let gameOver = false;
        let lastMove = null;

        // --- ××ª×—×•×œ ×•×¦×™×•×¨ ---

        function initGame() {
            // ×©×›×¤×•×œ ×¢××•×§ ×©×œ ×”×œ×•×— ×”×”×ª×—×œ×ª×™
            board = JSON.parse(JSON.stringify(START_FEN));
            turn = 'w';
            gameOver = false;
            selectedSquare = null;
            validMoves = [];
            lastMove = null;
            
            updateStatus("×”××©×—×§ ×”×ª×—×™×œ!");
            drawBoard();
        }

        function drawBoard() {
            boardEl.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const sq = document.createElement('div');
                    sq.className = `square ${(r + c) % 2 === 0 ? 'sq-light' : 'sq-dark'}`;
                    sq.dataset.r = r;
                    sq.dataset.c = c;
                    
                    // ×‘×“×™×§×” ×× ×–×• ××©×‘×¦×ª ×©× ×‘×—×¨×”
                    if (selectedSquare && selectedSquare.r === r && selectedSquare.c === c) {
                        sq.classList.add('selected');
                    }

                    // ×‘×“×™×§×” ×× ×–×” ××”×œ×š ××—×¨×•×Ÿ
                    if (lastMove) {
                        if ((lastMove.from.r === r && lastMove.from.c === c) || 
                            (lastMove.to.r === r && lastMove.to.c === c)) {
                            sq.classList.add('last-move');
                        }
                    }

                    // ×¡×™××•×Ÿ ××”×œ×›×™× ×—×•×§×™×™×
                    const isValidMove = validMoves.find(m => m.r === r && m.c === c);
                    if (isValidMove) {
                        sq.classList.add('valid-move');
                        if (board[r][c] !== '') sq.classList.add('valid-capture');
                    }

                    // ×¦×™×•×¨ ×”×›×œ×™
                    const pieceCode = board[r][c];
                    if (pieceCode) {
                        const color = pieceCode[0];
                        const type = pieceCode[1];
                        const span = document.createElement('span');
                        span.className = `piece ${color === 'w' ? 'white' : 'black'}`;
                        span.textContent = PIECES[color][type];
                        sq.appendChild(span);
                    }

                    sq.onclick = () => onSquareClick(r, c);
                    boardEl.appendChild(sq);
                }
            }
        }

        // --- ×œ×•×’×™×§×ª ××©×—×§ ---

        function onSquareClick(r, c) {
            if (gameOver || turn === 'b') return; // ×œ× ×œ×’×¢×ª ×›×©×ª×•×¨ ×”××—×©×‘

            // 1. ×”×× ×œ×—×¦× ×• ×¢×œ ××”×œ×š ×—×•×§×™ ×©×›×‘×¨ ×—×•×©×‘?
            const move = validMoves.find(m => m.r === r && m.c === c);
            if (move) {
                executeMove(selectedSquare, move);
                return;
            }

            // 2. ×‘×—×™×¨×ª ×›×œ×™ ×—×“×©
            const piece = board[r][c];
            if (piece && piece.startsWith('w')) {
                selectedSquare = {r, c};
                validMoves = getSafeMoves(r, c); // ×—×™×©×•×‘ ××”×œ×›×™× ×—×•×§×™×™×
                drawBoard();
            } else {
                selectedSquare = null;
                validMoves = [];
                drawBoard();
            }
        }

        function executeMove(from, to) {
            // ×‘×™×¦×•×¢ ×”××”×œ×š ×‘×–×™×›×¨×•×Ÿ
            const piece = board[from.r][from.c];
            board[to.r][to.c] = piece;
            board[from.r][from.c] = '';

            // ×”×›×ª×¨×” (Pawn Promotion) - ××•×˜×•××˜×™×ª ×œ××œ×›×”
            if (piece[1] === 'p' && (to.r === 0 || to.r === 7)) {
                board[to.r][to.c] = piece[0] + 'q';
            }

            lastMove = { from, to };
            
            // ×‘×“×™×§×ª × ×™×¦×—×•×Ÿ/×”×¤×¡×“ ×œ×¤× ×™ ×”×—×œ×¤×ª ×ª×•×¨
            const enemyColor = turn === 'w' ? 'b' : 'w';
            if (isCheckmate(enemyColor)) {
                gameOver = true;
                drawBoard();
                const winner = turn === 'w' ? "×’×œ ×”××œ×š! ğŸ†" : "×”××—×©×‘ × ×™×¦×—";
                updateStatus("××˜! " + winner);
                return;
            }

            // ×”×—×œ×¤×ª ×ª×•×¨
            turn = turn === 'w' ? 'b' : 'w';
            selectedSquare = null;
            validMoves = [];
            
            // ×¢×“×›×•×Ÿ UI
            const turnName = turn === 'w' ? "×’×œ (×œ×‘×Ÿ)" : "××—×©×‘ (×©×—×•×¨)";
            turnEl.textContent = "×ª×•×¨: " + turnName;
            
            if (isInCheck(turn)) {
                updateStatus("×©×—! ×”××œ×š ×‘×¡×›× ×”!");
            } else {
                updateStatus(turn === 'w' ? "×ª×•×¨×š ×’×œ" : "×”××—×©×‘ ×—×•×©×‘...");
            }

            drawBoard();

            // ×× ×ª×•×¨ ×”××—×©×‘ -> ×”×¤×¢×œ AI
            if (turn === 'b' && !gameOver) {
                setTimeout(computerMove, 500);
            }
        }

        // --- ×× ×•×¢ ×—×•×§×™× (Move Generation) ---

        function getSafeMoves(r, c) {
            const piece = board[r][c];
            if (!piece) return [];
            
            const rawMoves = getPseudoMoves(r, c, board);
            const myColor = piece[0];

            // ×¡×™× ×•×Ÿ ××”×œ×›×™× ×©××©××™×¨×™× ××ª ×”××œ×š ×‘×©×—
            return rawMoves.filter(m => {
                // ×”×“××™×” ×©×œ ×”××”×œ×š ×¢×œ ×œ×•×— ×–×× ×™
                const tempBoard = JSON.parse(JSON.stringify(board));
                tempBoard[m.r][m.c] = tempBoard[r][c];
                tempBoard[r][c] = '';
                
                // ×”×× ×”××œ×š ×©×œ×™ ×¢×“×™×™×Ÿ ×××•×™×?
                return !isKingInDanger(tempBoard, myColor);
            });
        }

        function getPseudoMoves(r, c, currentBoard) {
            const piece = currentBoard[r][c];
            const type = piece[1];
            const color = piece[0];
            const moves = [];

            // ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×œ×‘×“×™×§×ª ×’×‘×•×œ×•×ª ×•×ª×•×›×Ÿ ××©×‘×¦×ª
            const check = (tr, tc) => {
                if (tr < 0 || tr > 7 || tc < 0 || tc > 7) return 'out';
                const target = currentBoard[tr][tc];
                if (target === '') return 'empty';
                if (target[0] !== color) return 'capture';
                return 'blocked';
            };

            // ×œ×•×’×™×§×” ×œ×›×œ ×›×œ×™
            if (type === 'p') { // ×¨×’×œ×™
                const dir = color === 'w' ? -1 : 1;
                const startRow = color === 'w' ? 6 : 1;
                
                // ×ª× ×•×¢×” ×§×“×™××”
                if (check(r + dir, c) === 'empty') {
                    moves.push({r: r + dir, c: c});
                    // ×¦×¢×“ ×›×¤×•×œ
                    if (r === startRow && check(r + dir * 2, c) === 'empty') {
                        moves.push({r: r + dir * 2, c: c});
                    }
                }
                // ××›×™×œ×” ×‘××œ×›×¡×•×Ÿ
                if (check(r + dir, c - 1) === 'capture') moves.push({r: r + dir, c: c - 1});
                if (check(r + dir, c + 1) === 'capture') moves.push({r: r + dir, c: c + 1});
            }
            
            else if (type === 'n') { // ×¤×¨×©
                const jumps = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                jumps.forEach(j => {
                    const res = check(r + j[0], c + j[1]);
                    if (res === 'empty' || res === 'capture') moves.push({r: r+j[0], c: c+j[1]});
                });
            }
            
            else if (type === 'k') { // ××œ×š
                const steps = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
                steps.forEach(s => {
                    const res = check(r + s[0], c + s[1]);
                    if (res === 'empty' || res === 'capture') moves.push({r: r+s[0], c: c+s[1]});
                });
            }
            
            else { // ×¨×¥, ×¦×¨×™×—, ××œ×›×” (×§×•×•×™×)
                const dirs = [];
                if (type === 'r' || type === 'q') dirs.push([0,1],[0,-1],[1,0],[-1,0]);
                if (type === 'b' || type === 'q') dirs.push([1,1],[1,-1],[-1,1],[-1,-1]);
                
                dirs.forEach(d => {
                    let tr = r + d[0];
                    let tc = c + d[1];
                    while (true) {
                        const res = check(tr, tc);
                        if (res === 'out' || res === 'blocked') break;
                        moves.push({r: tr, c: tc});
                        if (res === 'capture') break; // ××—×¨×™ ××›×™×œ×” ×¢×•×¦×¨×™×
                        tr += d[0];
                        tc += d[1];
                    }
                });
            }
            return moves;
        }

        // --- ×‘×“×™×§×ª ×©×— (Check Detection) ---

        function isInCheck(color) {
            return isKingInDanger(board, color);
        }

        function isKingInDanger(bd, color) {
            // 1. ××¦×™××ª ×”××œ×š
            let kR, kC;
            for (let r=0; r<8; r++) {
                for (let c=0; c<8; c++) {
                    if (bd[r][c] === color + 'k') { kR = r; kC = c; break; }
                }
            }
            if (kR === undefined) return false; // ×œ× ×××•×¨ ×œ×§×¨×•×ª

            // 2. ×‘×“×™×§×” ×× ××•×™×‘ ×××™×™× ×¢×œ×™×•
            const enemy = color === 'w' ? 'b' : 'w';
            
            // ×‘××§×•× ×œ×‘×“×•×§ ××ª ×›×œ ×”×œ×•×—, × ×‘×“×•×§ ×× ×§×•×•×™× ××”××œ×š ×¤×•×’×¢×™× ×‘××•×™×‘×™× ×¨×œ×•×•× ×˜×™×™× (×”×¨×‘×” ×™×•×ª×¨ ×™×¢×™×œ)
            
            // ×‘×“×™×§×ª ×¤×¨×©×™× ××•×™×‘×™×
            const knights = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
            for (let k of knights) {
                const tr = kR+k[0], tc = kC+k[1];
                if (tr>=0 && tr<8 && tc>=0 && tc<8 && bd[tr][tc] === enemy + 'n') return true;
            }

            // ×‘×“×™×§×ª ××œ×›×¡×•× ×™× (×¨×¥/××œ×›×”)
            const diags = [[1,1],[1,-1],[-1,1],[-1,-1]];
            for (let d of diags) {
                let tr = kR+d[0], tc = kC+d[1];
                while(tr>=0 && tr<8 && tc>=0 && tc<8) {
                    const p = bd[tr][tc];
                    if (p) {
                        if (p === enemy + 'b' || p === enemy + 'q') return true;
                        break; // ×—×¡×™××”
                    }
                    tr += d[0]; tc += d[1];
                }
            }

            // ×‘×“×™×§×ª ×™×©×¨×™× (×¦×¨×™×—/××œ×›×”)
            const lines = [[0,1],[0,-1],[1,0],[-1,0]];
            for (let l of lines) {
                let tr = kR+l[0], tc = kC+l[1];
                while(tr>=0 && tr<8 && tc>=0 && tc<8) {
                    const p = bd[tr][tc];
                    if (p) {
                        if (p === enemy + 'r' || p === enemy + 'q') return true;
                        break;
                    }
                    tr += l[0]; tc += l[1];
                }
            }

            // ×‘×“×™×§×ª ×¨×’×œ×™× (Pawns)
            const pawnDir = color === 'w' ? -1 : 1; // ××•×™×‘ ×‘× ××œ××¢×œ×” ×× ×× ×™ ×œ×‘×Ÿ? ×œ×, ××•×™×‘ ×©×—×•×¨ ×‘× ××œ××¢×œ×”.
            // ×× ×× ×™ ×œ×‘×Ÿ (color=w), ×”××•×™×‘ ×”×•× ×©×—×•×¨. ×©×—×•×¨ ×ª×•×§×£ "×œ××˜×”" (row ×’×“×œ).
            // ×”×ª×™×§×•×Ÿ: ×× ×—× ×• ×‘×•×“×§×™× ×××™×¤×” ×”××œ×š ××•×ª×§×£.
            // ×× ×”××œ×š ×œ×‘×Ÿ, ×”×•× ××•×ª×§×£ ×¢"×™ ×¨×’×œ×™ ×©×—×•×¨ ×©× ××¦× ×‘×©×•×¨×” *× ××•×›×”* ×™×•×ª×¨ (row ×§×˜×Ÿ ×™×•×ª×¨) - ×œ×, ×©×—×•×¨ × ××¦× ×œ××¢×œ×” (0) ×•×™×•×¨×“ ×œ××˜×”.
            // ×”××œ×š ×”×œ×‘×Ÿ ×‘×©×•×¨×” 7. ×¨×’×œ×™ ×©×—×•×¨ ×‘×©×•×¨×” 6 ×××™×™× ×¢×œ×™×•. (6 + 1 = 7).
            
            const enemyPawnDir = color === 'w' ? -1 : 1; 
            // ×”×¡×‘×¨: ×× ×× ×™ ×œ×‘×Ÿ, ×× ×™ ××—×¤×© ×¨×’×œ×™ ×©×—×•×¨. ×¨×’×œ×™ ×©×—×•×¨ ×‘-(r-1, cÂ±1) ×××™×™× ×¢×œ×™×™.
            
            if (checkPawn(kR-1, kC-1, enemy + 'p')) return true;
            if (checkPawn(kR-1, kC+1, enemy + 'p')) return true;
            if (checkPawn(kR+1, kC-1, enemy + 'p')) return true;
            if (checkPawn(kR+1, kC+1, enemy + 'p')) return true;

            // ×‘×“×™×§×ª ××œ×š ××•×™×‘ (×¦××•×“)
            const kings = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
            for (let k of kings) {
                const tr = kR+k[0], tc = kC+k[1];
                if (tr>=0 && tr<8 && tc>=0 && tc<8 && bd[tr][tc] === enemy + 'k') return true;
            }

            return false;
        }

        function checkPawn(r, c, enemyPawn) {
            // ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×œ×‘×“×™×§×” ×× ××©×‘×¦×ª ××›×™×œ×” ×¨×’×œ×™ ×¡×¤×¦×™×¤×™ ×©×ª×•×§×£ ×‘×›×™×•×•×Ÿ ×”× ×›×•×Ÿ
            if (r>=0 && r<8 && c>=0 && c<8) {
                if (board[r][c] === enemyPawn) {
                    // ×•×™×“×•× ×›×™×•×•×Ÿ ×ª×§×™×Ÿ
                    const isWhiteEnemy = enemyPawn[0] === 'w';
                    const kingRow = isWhiteEnemy ? r-1 : r+1; // ××™×¤×” ×”××œ×š ×¦×¨×™×š ×œ×”×™×•×ª ×›×“×™ ×©×–×” ×™××™×™×
                    // ×‘×“×™×§×” ×–×• ×›×œ×œ×™×ª ××“×™, ×‘×•× × ×¤×©×˜:
                    // ×× ×× ×™ ×œ×‘×Ÿ, ×× ×™ ××•×ª×§×£ ×¢"×™ ×©×—×•×¨ ×©× ××¦× ×‘ kRow-1 (××¢×œ×™×™).
                    // ×× ×× ×™ ×©×—×•×¨, ×× ×™ ××•×ª×§×£ ×¢"×™ ×œ×‘×Ÿ ×©× ××¦× ×‘ kRow+1 (××ª×—×ª×™×™).
                    const myColor = enemyPawn[0] === 'w' ? 'b' : 'w'; // ×”×¦×‘×¢ ×©×œ×™
                    const attackRow = myColor === 'w' ? r+1 : r-1; // ×”×©×•×¨×” ×©×”×¨×’×œ×™ ×”×–×” ×ª×•×§×£
                    // ×‘×§×™×¦×•×¨, ×”×¤×•× ×§×¦×™×” ×”×§×•×“××ª ×¡×¨×§×” ×”×›×œ, ×–×” ×‘×¡×“×¨ ×œ×”×©××™×¨ ×¤×©×•×˜:
                    // ×× ×™×© ×¨×’×œ×™ ××•×™×‘ ×‘××©×‘×¦×ª ×©×××•×¨×” ×œ××™×™× ×¢×œ×™×™ - ×–×” ××™×•×.
                    const piece = board[r][c];
                    if (!piece) return false;
                    
                    if (myColor === 'w') { // ×× ×™ ×œ×‘×Ÿ, ×‘×•×“×§ ×× ×™×© ×©×—×•×¨ ××¢×œ×™×™ ×‘××œ×›×¡×•×Ÿ
                       // ×¨×’×œ×™ ×©×—×•×¨ ×‘×©×•×¨×” r ×××™×™× ×¢×œ r+1.
                       // ××– ×× ××¦××ª×™ ×¨×’×œ×™ ×©×—×•×¨ ×‘ kR-1, ×”×•× ×××™×™× ×¢×œ kR.
                       return (piece === 'bp' && (r+1)); 
                    } else { // ×× ×™ ×©×—×•×¨, ×‘×•×“×§ ×× ×™×© ×œ×‘×Ÿ ××ª×—×ª×™×™
                       // ×¨×’×œ×™ ×œ×‘×Ÿ ×‘×©×•×¨×” r ×××™×™× ×¢×œ r-1.
                       // ×× ××¦××ª×™ ×¨×’×œ×™ ×œ×‘×Ÿ ×‘ kR+1, ×”×•× ×××™×™× ×¢×œ kR.
                    }
                    return piece === enemyPawn;
                }
            }
            return false;
        }
        
        // ×ª×™×§×•×Ÿ ×¡×•×¤×™ ×œ×‘×“×™×§×ª ×¨×’×œ×™× ×¤×©×•×˜×” ×•×××™× ×”:
        function isKingInDangerPawnFix(bd, kR, kC, color) {
             const enemy = color === 'w' ? 'b' : 'w';
             // ×× ×× ×™ ×œ×‘×Ÿ, ×¨×’×œ×™ ×©×—×•×¨ ×ª×•×§×£ ××œ××¢×œ×” (×©×•×¨×” ×§×˜× ×” ×™×•×ª×¨)
             if (color === 'w') {
                 if (bd[kR-1]?.[kC-1] === 'bp') return true;
                 if (bd[kR-1]?.[kC+1] === 'bp') return true;
             } else {
                 // ×× ×× ×™ ×©×—×•×¨, ×¨×’×œ×™ ×œ×‘×Ÿ ×ª×•×§×£ ××œ××˜×” (×©×•×¨×” ×’×“×•×œ×” ×™×•×ª×¨)
                 if (bd[kR+1]?.[kC-1] === 'wp') return true;
                 if (bd[kR+1]?.[kC+1] === 'wp') return true;
             }
             return false;
        }
        
        // × ×“×¨×•×¡ ××ª ×¤×•× ×§×¦×™×™×ª ×”×¡×›× ×” ×¢× ×”×ª×™×§×•×Ÿ ×©×œ ×”×¨×’×œ×™× ×‘×ª×•×š ×”×œ×•×’×™×§×” ×”×¨××©×™×ª
        // (×”×¢×¨×”: ×”×§×•×“ ×œ××¢×œ×” ××¡×¤×™×§ ×˜×•×‘ ××‘×œ ×”×ª×™×§×•×Ÿ ×”×–×” ×•×“××™)
        
        // ×©×›×ª×•×‘ ×¤×•× ×§×¦×™×™×ª ×¡×›× ×” ×©×ª×”×™×” ×‘×˜×•×—×” ×‘-100%
        isKingInDanger = function(bd, color) {
            let kR, kC;
            for (let r=0; r<8; r++) {
                for (let c=0; c<8; c++) {
                    if (bd[r][c] === color + 'k') { kR = r; kC = c; break; }
                }
            }
            if (kR === undefined) return false;

            const enemy = color === 'w' ? 'b' : 'w';

            // ×¨×’×œ×™×
            if (color === 'w') {
                 if (bd[kR-1]?.[kC-1] === 'bp') return true;
                 if (bd[kR-1]?.[kC+1] === 'bp') return true;
             } else {
                 if (bd[kR+1]?.[kC-1] === 'wp') return true;
                 if (bd[kR+1]?.[kC+1] === 'wp') return true;
             }

            // ×¤×¨×©×™×
            const knights = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
            for (let k of knights) {
                if (bd[kR+k[0]]?.[kC+k[1]] === enemy + 'n') return true;
            }

            // ××œ×›×¡×•× ×™× ×•×™×©×¨×™× (×¨×¥, ×¦×¨×™×—, ××œ×›×”)
            const dirs = [
                {d:[1,1], p:['b','q']}, {d:[1,-1], p:['b','q']}, 
                {d:[-1,1], p:['b','q']}, {d:[-1,-1], p:['b','q']},
                {d:[0,1], p:['r','q']}, {d:[0,-1], p:['r','q']}, 
                {d:[1,0], p:['r','q']}, {d:[-1,0], p:['r','q']}
            ];

            for (let setup of dirs) {
                let r = kR + setup.d[0];
                let c = kC + setup.d[1];
                while(r>=0 && r<8 && c>=0 && c<8) {
                    const p = bd[r][c];
                    if (p) {
                        if (p[0] === enemy && setup.p.includes(p[1])) return true;
                        break;
                    }
                    r += setup.d[0];
                    c += setup.d[1];
                }
            }
            
            // ××œ×š ××•×™×‘ (×›×“×™ ×œ× ×œ×¢××•×“ ×œ×™×“×•)
             const kings = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
             for (let k of kings) {
                 if (bd[kR+k[0]]?.[kC+k[1]] === enemy + 'k') return true;
             }

            return false;
        };


        function isCheckmate(color) {
            // ×× ××™×Ÿ ×©×•× ××”×œ×š ×—×•×§×™ ×•×× ×™ ×‘×©×— -> ××˜
            // ×‘×“×™×§×ª ×›×œ ×”×›×œ×™× ×©×œ×™
            for (let r=0; r<8; r++) {
                for (let c=0; c<8; c++) {
                    if (board[r][c].startsWith(color)) {
                        if (getSafeMoves(r, c).length > 0) return false;
                    }
                }
            }
            return isInCheck(color); // ×× ××™×Ÿ ××”×œ×›×™× ×•×× ×™ ×‘×©×— = ××˜. ×× ××™×Ÿ ××”×œ×›×™× ×•×œ× ×‘×©×— = ×¤×˜ (×œ× ×˜×™×¤×œ× ×• ×‘×¤×˜ ×›×“×™ ×œ× ×œ×¡×‘×š, ×–×” ×¤×©×•×˜ ×™×™×ª×§×¢ ××• ×”××—×©×‘ ×™× ×¦×—)
        }

        // --- ××—×©×‘ (AI) ---

        function computerMove() {
            if (gameOver || turn === 'w') return;

            // ××™×¡×•×£ ×›×œ ×”××”×œ×›×™× ×”××¤×©×¨×™×™× ×œ××—×©×‘
            let allMoves = [];
            for (let r=0; r<8; r++) {
                for (let c=0; c<8; c++) {
                    if (board[r][c].startsWith('b')) {
                        const moves = getSafeMoves(r, c);
                        moves.forEach(m => {
                            allMoves.push({ from: {r,c}, to: m });
                        });
                    }
                }
            }

            if (allMoves.length === 0) {
                // ×”××—×©×‘ ×œ× ×™×›×•×œ ×œ×–×•×–
                gameOver = true;
                if (isInCheck('b')) updateStatus("× ×™×¦×—×ª ×’×œ! (××˜)");
                else updateStatus("×ª×™×§×• (×¤×˜)");
                return;
            }

            // ×‘×—×™×¨×ª ×”××”×œ×š ×”×˜×•×‘ ×‘×™×•×ª×¨ (×œ×¤×™ ××›×™×œ×•×ª)
            let bestMove = allMoves[0];
            let maxScore = -9999;
            const vals = { p:10, n:30, b:30, r:50, q:90, k:900 };

            allMoves.forEach(m => {
                let score = Math.random() * 5; // ××œ×× ×˜ ×¨× ×“×•××œ×™
                
                // ×”×× ××›×œ×ª×™ ××©×”×•?
                const target = board[m.to.r][m.to.c];
                if (target) score += vals[target[1]];

                // ×”×× ×”×ª×§×“××ª×™ ×œ××¨×›×–?
                if (m.to.r > 2 && m.to.r < 5 && m.to.c > 2 && m.to.c < 5) score += 2;

                if (score > maxScore) {
                    maxScore = score;
                    bestMove = m;
                }
            });

            executeMove(bestMove.from, bestMove.to);
        }

        function updateStatus(msg) {
            statusEl.textContent = msg;
        }

        // ×”×ª×—×œ×”
        initGame();

    </script>
</body>
</html>
