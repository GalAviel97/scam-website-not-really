<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <title>4 砖专 砖  </title>
    <style>
        :root {
            --bg-dark: #0f172a;
            --board-blue: #1e3a8a;
            --gal-gold: #fbbf24;
            --pc-dark: #334155;
            --shadow: rgba(0, 0, 0, 0.5);
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: radial-gradient(circle at center, #1e293b, #020617);
            color: white;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            direction: rtl;
        }

        h1 {
            font-size: 3.5rem;
            color: var(--gal-gold);
            margin: 0 0 10px 0;
            text-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
        }

        .subtitle {
            color: #94a3b8;
            margin-bottom: 20px;
            font-size: 1.2rem;
        }

        .game-wrapper {
            background: rgba(255, 255, 255, 0.05);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            text-align: center;
            border: 1px solid rgba(251, 191, 36, 0.2);
        }

        .status {
            font-size: 1.5rem;
            margin-bottom: 15px;
            font-weight: bold;
            min-height: 40px;
            color: white;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(7, 80px);
            grid-template-rows: repeat(6, 80px);
            gap: 10px;
            background-color: var(--board-blue);
            padding: 15px;
            border-radius: 15px;
            border: 4px solid #3b82f6;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.6);
            position: relative;
        }

        /* 专爪  */
        .cell {
            width: 80px;
            height: 80px;
            background-color: var(--bg-dark); /* 专 砖拽祝  */
            border-radius: 50%;
            cursor: pointer;
            position: relative;
            box-shadow: inset 0 5px 10px rgba(0,0,0,0.8);
            overflow: hidden; /*  砖爪  转爪 爪 */
        }
        
        /* 注 (爪 ) */
        .column-hover {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 80px;
            background: rgba(255,255,255,0.0);
            cursor: pointer;
            z-index: 10;
        }
        .column-hover:hover {
            background: rgba(255,255,255,0.1);
        }

        /* 住拽转 */
        .disc {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            transform: translateY(-500px); /* 转 注 */
            animation: drop 0.5s cubic-bezier(0.5, 0, 0.5, 1.5) forwards;
        }

        .disc.gold {
            background: radial-gradient(circle at 30% 30%, #fcd34d, #b45309);
            box-shadow: 0 4px 6px rgba(0,0,0,0.4);
        }

        .disc.dark {
            background: radial-gradient(circle at 30% 30%, #64748b, #0f172a);
            box-shadow: 0 4px 6px rgba(0,0,0,0.4);
        }

        @keyframes drop {
            to { transform: translateY(0); }
        }

        button {
            background: linear-gradient(135deg, #eab308, #ca8a04);
            border: none;
            padding: 12px 30px;
            color: #0f172a;
            font-weight: bold;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(234, 179, 8, 0.5);
        }

        .win-line {
            border: 4px solid #fff;
        }
        
        @media (max-width: 700px) {
            .board { grid-template-columns: repeat(7, 12vw); grid-template-rows: repeat(6, 12vw); gap: 1vw; padding: 2vw;}
            .cell { width: 12vw; height: 12vw; }
            h1 { font-size: 2rem; }
        }

    </style>
</head>
<body>

    <h1>4 砖专 砖  </h1>
    <div class="subtitle"> 转爪 爪 转 砖?</div>

    <div class="game-wrapper">
        <div class="status" id="status">转专, ! ()</div>
        
        <div class="board" id="board">
            </div>

        <button onclick="initGame()">砖拽 砖</button>
    </div>

    <script>
        // --- 专转 ---
        const ROWS = 6;
        const COLS = 7;
        const PLAYER = 1; // 
        const AI = 2;     // 砖
        const EMPTY = 0;

        let board = [];
        let gameActive = false;
        let currentPlayer = PLAYER;

        // --- 转 ---
        function initGame() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));
            gameActive = true;
            currentPlayer = PLAYER;
            document.getElementById('status').innerText = "转专, ! ()";
            document.getElementById('status').style.color = "white";
            drawBoard();
        }

        function drawBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = ''; // 拽

            // 爪专转 专 爪 (注转)
            for (let c = 0; c < COLS; c++) {
                const colHover = document.createElement('div');
                colHover.className = 'column-hover';
                colHover.style.left = (c * (window.innerWidth < 700 ? window.innerWidth * 0.13 : 90) + 15) + 'px'; 
                // 注专: 砖 拽 拽 -CSS 专住驻住 专,  驻 砖转砖 拽 驻砖 转专:
                // 拽 div  注 注, 砖转砖 -Click 注 -cell 注爪 砖 注.
            }

            // 爪专转 转
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.col = c; // 注  注 
                    cell.onclick = () => handleMove(c);

                    //  砖 住拽转
                    if (board[r][c] !== EMPTY) {
                        const disc = document.createElement('div');
                        disc.className = `disc ${board[r][c] === PLAYER ? 'gold' : 'dark'}`;
                        //  爪 爪专 砖 (专拽  砖 砖 爪)
                        disc.style.animation = 'none';
                        disc.style.transform = 'translateY(0)';
                        cell.appendChild(disc);
                    }
                    boardEl.appendChild(cell);
                }
            }
        }

        // 驻拽爪 住驻转 住拽转 注 爪
        function addDiscToUI(r, c, player) {
            const index = r * COLS + c;
            const cells = document.querySelectorAll('.cell');
            const cell = cells[index];
            
            const disc = document.createElement('div');
            disc.className = `disc ${player === PLAYER ? 'gold' : 'dark'}`;
            cell.appendChild(disc);
        }

        // --- 拽转 砖拽 ---

        function handleMove(col) {
            if (!gameActive || currentPlayer !== PLAYER) return;

            // 爪转 砖专 驻 专砖 
            const row = getAvailableRow(col);
            if (row === -1) return; // 注 

            makeMove(row, col, PLAYER);
        }

        function makeMove(row, col, player) {
            board[row][col] = player;
            addDiscToUI(row, col, player);

            if (checkWin(player)) {
                gameActive = false;
                const msg = player === PLAYER ? "爪 ! " : "砖 爪 ";
                document.getElementById('status').innerText = msg;
                document.getElementById('status').style.color = player === PLAYER ? "var(--gal-gold)" : "#ef4444";
                return;
            }

            if (checkDraw()) {
                gameActive = false;
                document.getElementById('status').innerText = "转拽!  .";
                return;
            }

            // 驻转 转专
            currentPlayer = player === PLAYER ? AI : PLAYER;
            
            if (currentPlayer === AI) {
                document.getElementById('status').innerText = "砖 砖...";
                setTimeout(aiMove, 600); // 砖 拽
            } else {
                document.getElementById('status').innerText = "转专, !";
            }
        }

        function getAvailableRow(col) {
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][col] === EMPTY) return r;
            }
            return -1;
        }

        // --- 拽转 爪 ---
        function checkWin(player, checkBoard = board) {
            // 驻拽
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS - 3; c++) {
                    if (checkBoard[r][c] === player && checkBoard[r][c+1] === player && 
                        checkBoard[r][c+2] === player && checkBoard[r][c+3] === player) return true;
                }
            }
            // 
            for (let r = 0; r < ROWS - 3; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (checkBoard[r][c] === player && checkBoard[r+1][c] === player && 
                        checkBoard[r+2][c] === player && checkBoard[r+3][c] === player) return true;
                }
            }
            // 住 /
            for (let r = 3; r < ROWS; r++) {
                for (let c = 0; c < COLS - 3; c++) {
                    if (checkBoard[r][c] === player && checkBoard[r-1][c+1] === player && 
                        checkBoard[r-2][c+2] === player && checkBoard[r-3][c+3] === player) return true;
                }
            }
            // 住 \
            for (let r = 0; r < ROWS - 3; r++) {
                for (let c = 0; c < COLS - 3; c++) {
                    if (checkBoard[r][c] === player && checkBoard[r+1][c+1] === player && 
                        checkBoard[r+2][c+2] === player && checkBoard[r+3][c+3] === player) return true;
                }
            }
            return false;
        }

        function checkDraw() {
            return board[0].every(cell => cell !== EMPTY);
        }

        // --- AI (Minimax Algorithm) ---
        //   砖注砖 转 砖 

        function aiMove() {
            // 注拽 砖 (5  拽砖  驻驻)
            const depth = 5; 
            const [col, score] = minimax(board, depth, -Infinity, Infinity, true);
            
            if (col !== null) {
                const row = getAvailableRow(col);
                makeMove(row, col, AI);
            }
        }

        // 驻拽爪转 注专 砖 
        function evaluateWindow(window, piece) {
            let score = 0;
            const oppPiece = piece === PLAYER ? AI : PLAYER;

            let countPiece = window.filter(p => p === piece).length;
            let countEmpty = window.filter(p => p === EMPTY).length;
            let countOpp = window.filter(p => p === oppPiece).length;

            if (countPiece === 4) return 100;
            if (countPiece === 3 && countEmpty === 1) score += 5;
            if (countPiece === 2 && countEmpty === 2) score += 2;
            
            if (countOpp === 3 && countEmpty === 1) score -= 4; // 住 拽专转

            return score;
        }

        function scorePosition(bd, piece) {
            let score = 0;

            // 注驻 专
            const centerArray = [];
            for (let r = 0; r < ROWS; r++) centerArray.push(bd[r][3]);
            const centerCount = centerArray.filter(p => p === piece).length;
            score += centerCount * 3;

            // 拽转  转 驻砖专 (驻拽, , 住)
            // (拽 拽爪专 爪专 注转)
            
            // 驻拽
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS - 3; c++) {
                    const window = [bd[r][c], bd[r][c+1], bd[r][c+2], bd[r][c+3]];
                    score += evaluateWindow(window, piece);
                }
            }
            // 
            for (let r = 0; r < ROWS - 3; r++) {
                for (let c = 0; c < COLS; c++) {
                    const window = [bd[r][c], bd[r+1][c], bd[r+2][c], bd[r+3][c]];
                    score += evaluateWindow(window, piece);
                }
            }
            // 住
            for (let r = 0; r < ROWS - 3; r++) {
                for (let c = 0; c < COLS - 3; c++) {
                    const w1 = [bd[r][c], bd[r+1][c+1], bd[r+2][c+2], bd[r+3][c+3]];
                    const w2 = [bd[r+3][c], bd[r+2][c+1], bd[r+1][c+2], bd[r][c+3]]; // 住 驻 驻  驻专转
                    score += evaluateWindow(w1, piece);
                }
            }
            for (let r = 3; r < ROWS; r++) {
                 for (let c = 0; c < COLS - 3; c++) {
                    const w2 = [bd[r][c], bd[r-1][c+1], bd[r-2][c+2], bd[r-3][c+3]];
                    score += evaluateWindow(w2, piece);
                 }
            }

            return score;
        }

        // 专转 专拽专住
        function minimax(bd, depth, alpha, beta, maximizingPlayer) {
            const validLocations = [];
            for (let c=0; c<COLS; c++) {
                if (bd[0][c] === EMPTY) validLocations.push(c);
            }

            // 转 注爪专: 爪  注拽 0
            if (checkWin(AI, bd)) return [null, 1000000];
            if (checkWin(PLAYER, bd)) return [null, -1000000];
            if (validLocations.length === 0) return [null, 0];
            if (depth === 0) return [null, scorePosition(bd, AI)];

            if (maximizingPlayer) { // 转专 砖 (住 拽住 拽)
                let value = -Infinity;
                let column = validLocations[Math.floor(Math.random() * validLocations.length)];
                
                for (let col of validLocations) {
                    const row = getAvailableRowInBoard(bd, col);
                    const bCopy = bd.map(arr => arr.slice());
                    bCopy[row][col] = AI;
                    
                    const newScore = minimax(bCopy, depth - 1, alpha, beta, false)[1];
                    
                    if (newScore > value) {
                        value = newScore;
                        column = col;
                    }
                    alpha = Math.max(alpha, value);
                    if (alpha >= beta) break;
                }
                return [column, value];
            } else { // 转专 砖拽 (砖  砖转 转砖拽 驻  拽  拽)
                let value = Infinity;
                let column = validLocations[Math.floor(Math.random() * validLocations.length)];
                
                for (let col of validLocations) {
                    const row = getAvailableRowInBoard(bd, col);
                    const bCopy = bd.map(arr => arr.slice());
                    bCopy[row][col] = PLAYER;
                    
                    const newScore = minimax(bCopy, depth - 1, alpha, beta, true)[1];
                    
                    if (newScore < value) {
                        value = newScore;
                        column = col;
                    }
                    beta = Math.min(beta, value);
                    if (alpha >= beta) break;
                }
                return [column, value];
            }
        }

        function getAvailableRowInBoard(bd, col) {
            for (let r = ROWS - 1; r >= 0; r--) {
                if (bd[r][col] === EMPTY) return r;
            }
            return -1;
        }

        // 转
        initGame();

    </script>
</body>
</html>
